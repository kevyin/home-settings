"use strict";
/// <reference types="node" />
Object.defineProperty(exports, "__esModule", { value: true });
// The MIT License (MIT)
// 
// node-workflows (https://github.com/mkloubert/node-workflows)
// Copyright (c) Marcel Joachim Kloubert <marcel.kloubert@gmx.net>
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
const events = require("events");
/**
 * Global events.
 */
exports.EVENTS = new events.EventEmitter();
/**
 * Stores global values.
 */
exports.GLOBALS = {};
/**
 * List of log categories.
 */
var LogCategory;
(function (LogCategory) {
    /**
     * Emergency: system is unusable
     */
    LogCategory[LogCategory["Emergency"] = 0] = "Emergency";
    /**
     * Alert: action must be taken immediately
     */
    LogCategory[LogCategory["Alert"] = 1] = "Alert";
    /**
     * Critical: critical conditions
     */
    LogCategory[LogCategory["Critical"] = 2] = "Critical";
    /**
     * Error: error conditions
     */
    LogCategory[LogCategory["Error"] = 3] = "Error";
    /**
     * Warning: warning conditions
     */
    LogCategory[LogCategory["Warning"] = 4] = "Warning";
    /**
     * Notice: normal but significant condition
     */
    LogCategory[LogCategory["Notice"] = 5] = "Notice";
    /**
     * Informational: informational messages
     */
    LogCategory[LogCategory["Info"] = 6] = "Info";
    /**
     * Debug: debug messages
     */
    LogCategory[LogCategory["Debug"] = 7] = "Debug";
    /**
     * Trace: output the most you can
     */
    LogCategory[LogCategory["Trace"] = 8] = "Trace";
})(LogCategory = exports.LogCategory || (exports.LogCategory = {}));
/**
 * The initial value for 'logLevel' property of 'Workflow' class.
 */
exports.DefaultLogLevel = LogCategory.Notice;
/**
 * A workflow.
 */
class Workflow extends events.EventEmitter {
    /**
     * Initializes a new instance of that class.
     */
    constructor() {
        super();
        /**
         * Stores the actions of the Workflow.
         */
        this._actions = [];
        /**
         * Stores the permanent state values of the actions.
         */
        this._actionStates = [];
        /**
         * Stores the number of workflow execution.
         */
        this._executions = 0;
        /**
         * Stores the loggers.
         */
        this._loggers = [];
        /**
         * Stores the minimal log level.
         */
        this._logLevel = exports.DefaultLogLevel;
        /**
         * Stores the current state value.
         */
        this._state = exports.DefaultState;
        let defLoggers = exports.DefaultLoggers;
        if (defLoggers) {
            defLoggers.forEach(l => this.addLogger(l));
        }
    }
    /**
     * Adds a logger.
     *
     * @param {LoggerType} [logger] The logger to add.
     * @param {any} [thisArg] The optional object / value that should be linked with the underlying action.
     *
     * @chainable
     */
    addLogger(logger, thisArg) {
        if (arguments.length < 2) {
            thisArg = this;
        }
        if (logger) {
            let action;
            if ('function' === typeof logger) {
                action = logger;
            }
            else {
                let l = logger;
                action = function (ctx) {
                    l.log(ctx);
                };
            }
            let newLoggerCount = this._loggers.push({
                action: action,
                thisArg: thisArg,
            });
            this.emit('logger.new', [action, newLoggerCount]);
        }
        return this;
    }
    /**
     * Gets the number of workflow executions.
     */
    get executions() {
        return this._executions;
    }
    /**
     * Gets or sets the minimal log level.
     */
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(newValue) {
        let oldValue = this._logLevel;
        if (newValue !== oldValue) {
            this.notifyPropertyChanged('logLevel', oldValue, newValue);
        }
    }
    /**
     * Alias for 'then'.
     */
    next(executor, thisArg) {
        return this.then
            .apply(this, arguments);
    }
    /**
     * Notifies for a property change.
     *
     * @param {string} propertyName The name of the property.
     * @param {any} oldValue The old value.
     * @param {any} newValue The new value.
     *
     * @chainable
     */
    notifyPropertyChanged(propertyName, oldValue, newValue) {
        this.emit('property.changed', propertyName, newValue, oldValue);
        return this;
    }
    /**
     * Resets the workflow.
     *
     * @chainable
     */
    reset() {
        let oldEntries = this._actions.map(x => x);
        this._actions = [];
        this.emit('reset.actions', oldEntries);
        this._actionStates = [];
        this._executions = 0;
        this.resetLoggers();
        this.resetActionStates();
        this.resetState();
        this.emit('reset');
        return this;
    }
    /**
     * Resets the state values of the actions.
     *
     * @chainable
     */
    resetActionStates() {
        let oldStates = this._actionStates.map(x => x);
        this._actionStates = [];
        this.emit('reset.actionstates', oldStates);
        return this;
    }
    /**
     * Resets the loggers.
     *
     * @chainable
     */
    resetLoggers() {
        let oldLoggers = this._loggers.map(x => x);
        this._loggers = [];
        this.emit('reset.loggers', oldLoggers);
        return this;
    }
    /**
     * Resets the state value.
     *
     * @chainable
     */
    resetState() {
        let oldValue = this._state;
        this.setState(undefined);
        this.emit('reset.state', oldValue);
        return this;
    }
    /**
     * Sets the minimal log level.
     *
     * @param {LogCategory} newValue The new value.
     *
     * @chainable
     */
    setLogLevel(newValue) {
        this.logLevel = newValue;
        return this;
    }
    /**
     * Sets the state value.
     *
     * @param {any} newValue The new value.
     *
     * @chainable
     */
    setState(newValue) {
        this.state = newValue;
        return this;
    }
    /**
     * Starts the workflow.
     *
     * @param {any} [initialValue] The initial value for the execution.
     *
     * @returns {Promise<any>} The promise with the result of the workflow.
     */
    start(initialValue) {
        let me = this;
        return new Promise((resolve, reject) => {
            try {
                let oldExecutionsValue = me._executions;
                let newExecutionsValue = me._executions = oldExecutionsValue + 1;
                me.notifyPropertyChanged('executions', oldExecutionsValue, newExecutionsValue);
                let entries = me._actions.map(x => x);
                let actionStates = [];
                let globals = {};
                let nextAction;
                let actionEvents = new events.EventEmitter();
                let current;
                let executions = 0;
                let index = -1;
                let prevIndx;
                let prevEndTime;
                let prevStartTime;
                let prevVal;
                let result;
                let skipWhile;
                let startTime;
                let value = initialValue;
                let completed = (err) => {
                    let endTime = new Date();
                    actionEvents.removeAllListeners();
                    me.emit('end', err, newExecutionsValue, result, endTime, value, prevVal, prevIndx);
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(result);
                    }
                };
                nextAction = () => {
                    try {
                        current = null;
                        ++index;
                        if (index >= entries.length) {
                            completed(null);
                            return;
                        }
                        let e = entries[index];
                        ++executions;
                        let ctx;
                        ctx = {
                            alert: function (msg, tag, priority) {
                                return this.log(msg, tag, LogCategory.Alert, priority);
                            },
                            count: entries.length,
                            crit: function (msg, tag, priority) {
                                return this.log(msg, tag, LogCategory.Critical, priority);
                            },
                            current: undefined,
                            dbg: function (msg, tag, priority) {
                                return this.log(msg, tag, LogCategory.Debug, priority);
                            },
                            emerg: function (msg, tag, priority) {
                                return this.log(msg, tag, LogCategory.Emergency, priority);
                            },
                            err: function (msg, tag, priority) {
                                return this.log(msg, tag, LogCategory.Error, priority);
                            },
                            events: actionEvents,
                            executions: undefined,
                            finish: function () {
                                index = entries.length - 1;
                                return this;
                            },
                            globalEvents: exports.EVENTS,
                            globals: globals,
                            goBack: function (cnt) {
                                if (arguments.length < 1) {
                                    cnt = 1;
                                }
                                return this.goto(this.index - 1);
                            },
                            goto: function (newIndex) {
                                --newIndex;
                                if (newIndex < -1 || newIndex >= (entries.length - 1)) {
                                    throw new Error('Index out of range!');
                                }
                                index = newIndex;
                                return this;
                            },
                            gotoFirst: function () {
                                index = -1;
                                return this;
                            },
                            gotoLast: function () {
                                index = entries.length - 1 - 1;
                                return this;
                            },
                            gotoNext: function () {
                                index = this.index;
                                return this;
                            },
                            index: index,
                            info: function (msg, tag, priority) {
                                return this.log(msg, tag, LogCategory.Info, priority);
                            },
                            isBetween: index > 0 && (index < (entries.length - 1)),
                            isFirst: 0 === index,
                            isLast: (entries.length - 1) === index,
                            log: function (msg, tag, category, priority) {
                                if (arguments.length < 3) {
                                    category = LogCategory.Info;
                                }
                                if (category <= me.logLevel) {
                                    try {
                                        let logTime = new Date();
                                        me._loggers.map(x => x).forEach(le => {
                                            try {
                                                let loggerCtx = {
                                                    action: ctx,
                                                    category: category,
                                                    message: msg,
                                                    priority: priority,
                                                    tag: tag,
                                                    time: logTime,
                                                };
                                                le.action.apply(le.thisArg, [loggerCtx]);
                                            }
                                            catch (e) {
                                                console.log('[ERROR.node-workflows.2] ' + e);
                                            }
                                        });
                                    }
                                    catch (e) {
                                        console.log('[ERROR.node-workflows.1] ' + e);
                                    }
                                }
                                return this;
                            },
                            note: function (msg, tag, priority) {
                                return this.log(msg, tag, LogCategory.Notice, priority);
                            },
                            permanentGlobals: exports.GLOBALS,
                            permanentState: undefined,
                            previousEndTime: prevEndTime,
                            previousIndex: prevIndx,
                            previousStartTime: prevStartTime,
                            previousValue: prevVal,
                            repeat: function () {
                                return this.goto(this.index);
                            },
                            result: undefined,
                            skip: function (cnt) {
                                if (arguments.length < 1) {
                                    cnt = 1;
                                }
                                this.skipWhile = () => {
                                    if (cnt > 0) {
                                        --cnt;
                                        return true;
                                    }
                                    return false;
                                };
                                return this;
                            },
                            skipWhile: undefined,
                            startTime: startTime,
                            state: undefined,
                            time: undefined,
                            trace: function (msg, tag, priority) {
                                return this.log(msg, tag, LogCategory.Trace, priority);
                            },
                            value: undefined,
                            warn: function (msg, tag, priority) {
                                return this.log(msg, tag, LogCategory.Warning, priority);
                            },
                            workflowEvents: me,
                            workflowExecutions: me._executions,
                            workflowState: undefined,
                        };
                        // ctx.current
                        Object.defineProperty(ctx, 'current', {
                            enumerable: true,
                            get: function () {
                                return current;
                            }
                        });
                        // ctx.executions
                        Object.defineProperty(ctx, 'executions', {
                            enumerable: true,
                            get: function () {
                                return executions;
                            }
                        });
                        // ctx.permanentState
                        Object.defineProperty(ctx, 'permanentState', {
                            enumerable: true,
                            get: function () {
                                return me._actionStates[ctx.index];
                            },
                            set: function (newValue) {
                                me._actionStates[ctx.index] = newValue;
                            }
                        });
                        // ctx.result
                        Object.defineProperty(ctx, 'result', {
                            enumerable: true,
                            get: function () {
                                return result;
                            },
                            set: function (newValue) {
                                result = newValue;
                            }
                        });
                        // ctx.skipWhile
                        Object.defineProperty(ctx, 'skipWhile', {
                            enumerable: true,
                            get: function () {
                                return skipWhile;
                            },
                            set: function (newValue) {
                                skipWhile = newValue;
                            }
                        });
                        // ctx.state
                        Object.defineProperty(ctx, 'state', {
                            enumerable: true,
                            get: function () {
                                return actionStates[ctx.index];
                            },
                            set: function (newValue) {
                                actionStates[ctx.index] = newValue;
                            }
                        });
                        // ctx.value
                        Object.defineProperty(ctx, 'value', {
                            enumerable: true,
                            get: function () {
                                return value;
                            },
                            set: function (newValue) {
                                value = newValue;
                            }
                        });
                        // ctx.workflowState
                        Object.defineProperty(ctx, 'workflowState', {
                            enumerable: true,
                            get: function () {
                                return me.state;
                            },
                            set: function (newValue) {
                                me.state = newValue;
                            }
                        });
                        let actionCompleted = function (err, nextValue) {
                            prevEndTime = new Date();
                            if (arguments.length > 1) {
                                prevVal = nextValue;
                            }
                            else {
                                prevVal = ctx.nextValue;
                            }
                            prevIndx = ctx.index;
                            result = ctx.result;
                            value = ctx.value;
                            me.emit('action.after', err, ctx);
                            if (err) {
                                completed(err);
                            }
                            else {
                                nextAction();
                            }
                        };
                        let invokeAction = () => {
                            current = ctx;
                            prevEndTime = undefined;
                            prevStartTime = ctx.time = new Date();
                            me.emit('action.before', ctx);
                            if (e.action) {
                                let result = e.action
                                    .apply(e.thisArg, [ctx]);
                                if (result) {
                                    // promise => "async" execution
                                    result.then(function (nextValue) {
                                        if (arguments.length > 0) {
                                            actionCompleted(null, nextValue);
                                        }
                                        else {
                                            actionCompleted(null);
                                        }
                                    }, (err) => {
                                        actionCompleted(err); // error
                                    });
                                }
                                else {
                                    actionCompleted(null); // no result
                                }
                            }
                            else {
                                actionCompleted(null); // no action
                            }
                        };
                        let doSkip = false;
                        let skipOrNot = () => {
                            if (doSkip) {
                                me.emit('action.skip', ctx);
                                nextAction();
                            }
                            else {
                                skipWhile = null;
                                invokeAction();
                            }
                        };
                        if (skipWhile) {
                            let skipWhileResult = skipWhile(ctx);
                            if (skipWhileResult) {
                                if ('object' === typeof skipWhileResult) {
                                    skipWhileResult.then((skip) => {
                                        doSkip = skip;
                                        skipOrNot();
                                    }, (err) => {
                                        completed(err);
                                    });
                                }
                                else {
                                    doSkip = skipWhileResult;
                                    skipOrNot();
                                }
                            }
                            else {
                                skipOrNot();
                            }
                        }
                        else {
                            skipOrNot();
                        }
                    }
                    catch (e) {
                        me.emit('action.after', e);
                        completed(e);
                    }
                };
                startTime = new Date();
                me.emit('start', newExecutionsValue, value, startTime);
                nextAction(); // start with first action
                // (if available)
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Gets or sets state of that workflow.
     */
    get state() {
        return this._state;
    }
    set state(newValue) {
        let oldValue = this._state;
        if (newValue !== oldValue) {
            this.notifyPropertyChanged('state', oldValue, newValue);
        }
    }
    /**
     * Adds a new action.
     *
     * @param {WorkflowExecutorType} [executor] The executor to add.
     * @param {any} [thisArg] The optional object / value that should be linked with the underlying action.
     *
     * @chainable
     */
    then(executor, thisArg) {
        if (arguments.length < 2) {
            thisArg = this;
        }
        let action;
        if (executor) {
            if ('function' === typeof executor) {
                action = executor;
            }
            else {
                let e = executor;
                action = function (ctx) {
                    if (e.execute) {
                        e.execute(ctx);
                    }
                };
            }
        }
        else {
            action = executor;
        }
        let newActionCount = this._actions.push({
            action: action,
            thisArg: thisArg,
        });
        this.emit('action.new', action, newActionCount);
        return this;
    }
}
exports.Workflow = Workflow;
/**
 * Creates a new workflow.
 *
 * @param {...WorkflowExecutorType[]} firstExecutors The first executors.
 *
 * @returns {Workflow} The new workflow.
 */
function create(...firstExecutors) {
    let newWorkflow = new Workflow();
    if (firstExecutors) {
        firstExecutors.forEach(e => {
            newWorkflow.then(e);
        });
    }
    return newWorkflow;
}
exports.create = create;
/**
 * Starts a new workflow.
 *
 * @param {...WorkflowExecutorType[]} executors The first executors.
 *
 * @returns {Promise<any>} The promise with the result of the workflow.
 */
function start(...executors) {
    let newWorkflow = new Workflow();
    if (executors) {
        executors.forEach(e => {
            newWorkflow.then(e);
        });
    }
    return newWorkflow.start();
}
exports.start = start;
//# sourceMappingURL=index.js.map